-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package mastermind
@version 2022.0.0.0


-- | This module should contain your game code.
module Game

-- | The number of pegs in a code. You can change this value if you want to
--   play games with more than four pegs. You should make sure that you
--   reference this definition in your code instead of hard-coding the
--   number 4 or writing code that assumes this value is 4.
pegs :: Int

-- | Symbols are represented by characters.
type Symbol = Char

-- | The available symbols in the game.
symbols :: [Symbol]

-- | A code is represented by a list of symbols.
type Code = [Symbol]

-- | Guesses are scored using coloured and white markers. The first
--   component of the pair gives the number of coloured markers and the
--   right component gives the number of white markers.
type Score = (Int, Int)

-- | A player is either human or computer-controlled.
data Player
Human :: Player
Computer :: Player

-- | The first codemaker in a play session.
codemaker :: Player

-- | The first guess the AI will make.
firstGuess :: Code

-- | <a>correctGuess</a> <tt>score</tt> determines whether <tt>score</tt>
--   indicates that a guess was correct or not. For example:
--   
--   <pre>
--   &gt;&gt;&gt; correctGuess (pegs, 0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; correctGuess (3, 1)
--   False
--   </pre>
correctGuess :: Score -> Bool

-- | <a>validateCode</a> <tt>code</tt> checks that the code entered by a
--   human player is valid. In other words, it should have the length given
--   by <a>pegs</a> and it should only contain valid symbols. For example
--   (assuming default definitions of <a>pegs</a> and <a>symbols</a>):
--   
--   <pre>
--   &gt;&gt;&gt; validateCode "aabb"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validateCode "zzyy"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; validateCode "ab"
--   False
--   </pre>
validateCode :: Code -> Bool

-- | <a>codes</a> is a list of all possible codes. For example, assuming
--   default definitions of <a>pegs</a> and <a>symbols</a>:
--   
--   <pre>
--   &gt;&gt;&gt; codes
--   ["aaaa", "aaab", "aaac", "aaad", .., "fffe", "ffff"]
--   </pre>
codes :: [Code]

-- | <a>results</a> is a list of all possible scores. Assuming default
--   definitions of <a>pegs</a>:
--   
--   <pre>
--   &gt;&gt;&gt; results
--   [ (0,0), (0,1), (0,2), (0,3), (0,4), (1,0), (1,1), (1,2), (1,3), (2,0)
--   , (2,1), (2,2), (3,0), (4,0)
--   ]
--   </pre>
results :: [Score]

-- | <a>score</a> <tt>code guess</tt> scores <tt>guess</tt> against
--   <tt>code</tt>. Symbols which are in the right place and of the right
--   type score a coloured marker. Symbols which are of the right type but
--   in the wrong place score a white marker.
--   
--   <pre>
--   &gt;&gt;&gt; score "abcd" "aabb"
--   (1,1)
--   </pre>
score :: Code -> Code -> Score

-- | <a>nextGuess</a> <tt>remainingOptions</tt> chooses the next guess from
--   <tt>remainingOptions</tt>. If there is only one option left, choose
--   it. Otherwise, calculate the hit score for each code and choose the
--   code with the largest hit score.
nextGuess :: [Code] -> Code

-- | <a>eliminate</a> <tt>lastScore guess remainingOptions</tt> returns a
--   list of <a>Code</a>s in which all codes from <tt>remainingOptions</tt>
--   which would result in a different score for <tt>guess</tt> if they
--   were the code are removed. In other words, given the set of remaining
--   possible codes, narrow it down to those which would produce the same
--   score we got from the codemaker.
eliminate :: Score -> Code -> [Code] -> [Code]
